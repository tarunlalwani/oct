# ADR-003: Result Type Error Handling

## Status
Accepted

## Context
TypeScript's exception handling is uncheckedâ€”any function can throw, and callers have no compile-time indication of what errors to handle. This leads to missing error handling, inconsistent error types, and difficulty tracing error paths through the codebase.

We need error handling that is:
1. Explicit in function signatures
2. Type-safe at compile time
3. Consistent across all layers
4. Serializable for API responses

## Decision
Use `neverthrow` Result<T, E> for all error handling instead of exceptions.

Every use case returns `Promise<Result<Output, DomainError>>`:
```typescript
export async function createTaskUseCase(
  ctx: ExecutionContext,
  input: CreateTaskInput,
  repository: TaskRepository
): Promise<Result<CreateTaskOutput, DomainError>> {
  if (ctx.actorId === null) {
    return err(createError('UNAUTHORIZED', 'Authentication required', false));
  }
  // ...
  return ok({ task });
}
```

Errors are defined in `packages/core/src/schemas/error.ts`:
```typescript
export const domainErrorSchema = z.object({
  code: errorCodeSchema,      // 'UNAUTHORIZED' | 'FORBIDDEN' | 'NOT_FOUND' | etc.
  message: z.string(),
  details: z.record(z.any()).optional(),
  retryable: z.boolean(),
});
```

Callers must handle both cases explicitly:
```typescript
const result = await createTaskUseCase(ctx, input, repository);
if (result.isErr()) {
  return reply.status(errorToHttpStatus(result.error)).send(serializeError(result.error));
}
return reply.status(201).send(serializeSuccess(result.value));
```

## Consequences

**Positive:**
- **Type safety**: Compiler enforces error handling; cannot accidentally ignore failures
- **Explicit contracts**: Function signatures document all possible error outcomes
- **Consistent structure**: All errors have the same shape (code, message, retryable)
- **Testability**: Error paths are values that can be asserted against

**Negative:**
- **Verbosity**: Every call site requires `if (result.isErr())` handling
- **Learning curve**: Developers must understand Result monad patterns
- **Interop**: Integration with libraries that throw requires wrapping

**Neutral:**
- The `ok()` and `err()` helpers from `neverthrow` are re-exported from Core for convenience
- Repository interfaces also use Result types, ensuring error handling at all boundaries

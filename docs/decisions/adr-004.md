# ADR-004: ExecutionContext Pattern

## Status
Accepted

## Context
Use cases need access to contextual information: who is performing the action (actor), what workspace they're operating in, what permissions they have, and trace identifiers for logging. Global variables or singletons for this data create hidden dependencies, make testing difficult, and prevent parallel request handling.

We need a pattern that:
1. Makes dependencies explicit and visible
2. Supports testing with mock contexts
3. Works for both CLI (single-user) and server (multi-tenant) scenarios
4. Carries trace information through the call stack

## Decision
Pass `ExecutionContext` as the first parameter to all use cases.

The context schema (`packages/core/src/schemas/context.ts`):
```typescript
export const executionContextSchema = z.object({
  actorId: z.string().nullable(),      // null = unauthenticated
  workspaceId: z.string(),              // tenancy boundary
  permissions: z.array(z.string()),     // capability list
  environment: z.enum(['local', 'ci', 'server']),
  traceId: z.string().optional(),       // request correlation
  metadata: z.record(z.any()).nullable().optional(),
}).strict();
```

Use case signature pattern:
```typescript
export async function createTaskUseCase(
  ctx: ExecutionContext,
  input: CreateTaskInput,
  repository: TaskRepository
): Promise<Result<CreateTaskOutput, DomainError>>
```

Adapters construct context differently:
- **CLI** (`packages/cli/src/context/builder.ts`): Reads from environment variables, defaults to local development settings
- **Server** (`packages/server/src/context/builder.ts`): Extracts from HTTP headers (x-actor-id, x-workspace-id, x-permissions)

## Consequences

**Positive:**
- **Testability**: Tests inject explicit contexts; no mocking of global state
- **Immutability**: Context is a value object; use cases cannot mutate it
- **No hidden dependencies**: All required context is in the signature
- **Auditability**: Actor information is always available for authorization and logging

**Negative:**
- **Parameter overhead**: Every use case has an additional parameter
- **Propagation burden**: Deep call stacks must thread context through
- **Construction complexity**: Each adapter must build context appropriately

**Neutral:**
- Context validation via Zod ensures malformed contexts fail fast at system boundaries
- The pattern enables future features like request-scoped caching and rate limiting without signature changes

# ADR-001: Core-First Architecture

## Status
Accepted

## Context
OCT requires both a CLI interface for local usage and a REST API for remote integration. The challenge is maintaining consistent business logic across both delivery mechanisms without duplication or drift. Traditional approaches embed business logic in controllers or handlers, making testing difficult and leading to inconsistencies between interfaces.

We need a clear separation between what the application does (business logic) and how it is accessed (delivery mechanisms).

## Decision
All business logic lives in the `packages/core` package. CLI (`packages/cli`) and Server (`packages/server`) are thin adapters that delegate to Core.

The Core package contains:
- **Domain entities** (`domain/task.ts`): Pure functions for task state transitions
- **Use cases** (`use-cases/*.ts`): Orchestration of business operations
- **Schemas** (`schemas/*.ts`): Zod-validated input/output contracts
- **Ports** (`ports/*.ts`): Interfaces for external dependencies (repositories)

Adapters contain only:
- Input parsing (CLI flags, HTTP bodies)
- Execution context construction
- Calling Core use cases
- Formatting output for the specific interface

Example from `packages/cli/src/commands/task.ts`:
```typescript
const ctx = buildExecutionContext();
const repository = repoFactory.createRepository(ctx.workspaceId);
const result = await createTaskUseCase(ctx, parseResult.data, repository);
```

The same use case is called identically from `packages/server/src/routes/tasks.ts`.

## Consequences

**Positive:**
- **Testability**: Business logic tests run without HTTP servers or CLI frameworks
- **Consistency**: Both CLI and API exhibit identical behavior
- **Refactoring safety**: Changes to delivery mechanisms don't affect business rules
- **Parallel development**: Core and adapters can evolve independently

**Negative:**
- **Indirection**: Developers must navigate through adapter → use case → domain
- **Boilerplate**: Adapter code is repetitive (parse, validate, call, format)
- **Learning curve**: New developers must understand the layering convention

**Neutral:**
- Repository implementations live in `packages/infra`, maintaining the dependency rule (Core depends on abstractions, not implementations)
